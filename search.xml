<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[策略模式]]></title>
      <url>%2F2018%2F03%2F21%2Fa03%2F</url>
      <content type="text"><![CDATA[策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 策略模式涉及到三个角色： 环境（context）角色：持有一个strategy的引用 抽象策略（Strategy）角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为 题目举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public interface ChargeStrategy &#123; //策略方法 double costFee(float displacement, int person, int mileage);&#125;public class LocalBus implements ChargeStrategy &#123; @Override public double costFee(float displacement, int person, int mileage) &#123; int cost; if (displacement &lt;= 1) &#123; cost = 0; &#125; else &#123; cost = 10; &#125; if (person &gt;= 6) &#123; cost += 10; &#125; if (mileage &gt; 100) &#123; cost += (mileage - 200) / 100 * 20; &#125; System.out.println("本地车辆---&gt;" + cost); return cost; &#125;&#125;public class OtherBus implements ChargeStrategy &#123; @Override public double costFee(float displacement, int person, int mileage) &#123; int cost; if (displacement &lt;= 1 &amp;&amp; displacement &gt; 0) &#123; cost = 10; &#125; else if (displacement &lt;= 2) &#123; cost = 20; &#125; else &#123; cost = 30; &#125; if (person &gt;= 6) &#123; cost += 20; &#125; if (mileage &gt; 100) &#123; cost += (mileage - 100) / 100 * 20; &#125; System.out.println("外地车辆---&gt;" + cost); return cost; &#125;&#125;public class Fee &#123; //持有一个具体策略的对象 ChargeStrategy strategy; //构造函数，传入一个具体策略对象 public Fee(ChargeStrategy strategy) &#123; this.strategy = strategy; &#125; //策略方法，计算收费 public double charge(float displacement, int person, int mileage) &#123; return this.strategy.costFee(displacement, person, mileage); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Fee fee = new Fee(new LocalBus()); fee.charge(2.7f, 6, 310); Fee fee1 = new Fee(new OtherBus()); fee1.charge(2.7f, 6, 310); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（二）Android View的绘制流程]]></title>
      <url>%2F2018%2F03%2F21%2Fa02%2F</url>
      <content type="text"><![CDATA[2.1 绘制的整体流程绘制会从根视图（ViewRoot）的performTraversal()方法开始，从上到下遍历整个视图树，每个View控制负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。 视图的绘制过程分为三个步骤，分别是测量（Measure）、布局（Layout）和绘制（Draw）。 2.2 MeasureSpecMeasureSpec表示的是一个32位的整数值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。MeasureSpec是View类的一个静态内部类，用来说明如果测量这个View, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** @hide */ @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode &#123;&#125; //不指定测量模式 public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; //精确测量模式 public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; //最大值测量模式 public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //根据指定的大小和模式创建一个MeasureSpec public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; //获取mode @MeasureSpecMode public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //根据spec获取大小 public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; //微调某个MeasureSpec static int adjust(int measureSpec, int delta) &#123; final int mode = getMode(measureSpec); int size = getSize(measureSpec); if (mode == UNSPECIFIED) &#123; // No need to adjust size for UNSPECIFIED mode. return makeMeasureSpec(size, UNSPECIFIED); &#125; size += delta; if (size &lt; 0) &#123; Log.e(VIEW_LOG_TAG, "MeasureSpec.adjust: new size would be negative! (" + size + ") spec: " + toString(measureSpec) + " delta: " + delta); size = 0; &#125; return makeMeasureSpec(size, mode); &#125; &#125; SpecMode有三种： UNSPECIFIED： 不指定测量模式，父视图没有限制子视图大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少使用到 EXACTLY： 精确测量模式，layout_width,layout_height为具体数值或match_parent时生效 AT_MOST： 最大值模式，layout_width,layout_height为wrap_content时生效，此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸 2.3 MeasureMeasure操作用来计算View的实际大小，页面流程从performMeasure方法开始。VeiwGroup遍历自身所有子View，并逐个调用子View的measure方法实现测量操作。 123456789101112131415161718192021222324252627282930 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; //当view gone的时候不测量 if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); //根据父容器的MeasureSpec和子view的layoutParams来算子view的MesureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; 最终测量通过回调onMeasure方法实现。开发者在自定义View的时候可以通过重写onMeasure来自定义测量过程，如果没有重写则会默认直接调用getDefaultSize来获取View的宽高。 2.4 LayoutLayout过程用来确定View在父容器中的布局位置，它是有父容器获取子View的位置参数后，调用子View的layout方法并将位置参数传入实现的。 2.5 DrawDraw用来将控件绘制出来，从performDraw开始，每个view的draw方法绘制每个具体的view，绘制基本上分为6个步骤： 123456789101112131415161718192021222324252627282930public void draw(Canvas canvas)&#123; ... //1，绘制View的背景 drawBackGround(canvas); ... //2，如果需要的话，保存canvas的图层，为fading做准备 saveConut = canvas.getSaveCount(); ... canvas.saveLayer(left,top,right,top+length,null,flags); ... //3，绘制view的内容 onDraw(canvas); ... //4，绘制view的子view dispatchDraw(canvas); ... //5，如果需要，绘制view的fading边缘并恢复图层 canvas.drawRect(left,top,right,top+length,p); ... canvas.restoreToCount(saveCount); ... //6，绘制view的装饰（例如滚动条） onDrawScrollBars(canvas); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（一）Android触摸事件传递机制]]></title>
      <url>%2F2018%2F03%2F21%2Fa01%2F</url>
      <content type="text"><![CDATA[1.1 触摸事件的类型 ACTION_DOWN ACTION_MOVE ACTION_UP 在一次屏幕触摸操作中，ACTION_DOWN 和 ACTION_UP 这两个事件是必须的，而ACTION_MOVE视情况而定。 1.2 事件传递的三个阶段 分发（dispatch）事件的分发对应着dispatchTouchEvent方法1public boolean dispatchTouchEvent(MotionEvent ev) 方法返回值为true表示事件被当前视图消费掉，不再继续分发事件；方法返回值为super.dispatchTouchEvent表示继续分发该事件。如果当前视图是ViewGroup及其子类，则会调用onInterceptTouchEvent方法判断是否拦截事件。 拦截（intercept）事件的拦截对应着onInterceptTouchEvent方法，这个方法只有在ViewGroup及其子类中才有，在View和Activity中是不存在的。 1public boolean onInterceptTouchEvent(MotionEvent ev) 返回ture表示拦截这个事件，不继续分发给子视图，同时交由自身的onTouchEvent方法进行消费； 返回false或者super.onInterceptTouchEvent表示不对事件进行拦截，继续传递给子视图。 消费（consumer） 事件的消费对应着onTouchEvent方法 1public boolean onTouchEvent(MotionEvent ev) 该方法返回值为true表示当前视图处理对应的事件，事件将不会向上传递给父视图；返回值为false表示当前视图不处理这个事件，事件会传递给父视图的onTouchEvent方法进行处理。 在Android系统中，拥有事件传递处理能力的类有以下3种： Activity：拥有dispatchTouchEvent和onTouchEvent两个方法 ViewGroup：拥有dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent三个方法 View：拥有dispatchTouchEvent和onTouchEvent两个方法 1.3 View的事件传递机制 触摸事件的传递流程是从dispatchTouchEvent开始的，如果不进行人为干预，则事件将会依照嵌套层次从外层向内层传递，到达最内层View时，就有它的onTouchEvent方法处理，如果该方法能够消费该事件，则返回true，反之false，这时事件会重新向外层传递，并有外层View的onTouchEvent方法进行处理，以此类推 如果事件在向内层传递过程中由于人为干预，事件处理函数返回true，则会导致事件提前被消费掉，内层View将不会收到这个事件 View控制的事件触发顺序是先执行onTouch方法，在最后才执行onClick方法。如果onTouch返回为true，则事件不会继续传递，最后也不会调用onClick方法；如果为false，则事件继续传递。 1.4 ViewGroup的事件传递机制 触摸事件的传递顺序是由Activity到ViewGroup，再由ViewGroup递归传递给它的子View ViewGroup通过onInterceptTouchEvent方法对事件进行拦截，如果该方法返回true，则事件不会继续传递给子View，如果返回false或者super.onInterceptTouchEvent，则事件会继续传递给子View 在子View种对事件进行消费后，ViewGroup将接收不到任何事件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native学习心得（二）]]></title>
      <url>%2F2017%2F07%2F23%2Frn002%2F</url>
      <content type="text"><![CDATA[React Native学习心得（二）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native学习心得（一）]]></title>
      <url>%2F2017%2F06%2F29%2Frn001%2F</url>
      <content type="text"><![CDATA[在学习React Native的时候，自己难免会遇到各种各样的问题，所以本文旨在记录一些自己在学习中遇到的心得。 第一个坑。。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信公众号个性化菜单的实现]]></title>
      <url>%2F2017%2F04%2F16%2F%E5%BE%AE%E4%BF%A1%E4%B8%AA%E6%80%A7%E5%8C%96%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[功能实现：微信扫描两个不同的二维码，关注的是相同的公众号，同一个公众号向不同关注者展示不同的菜单，实现了一个用户分类的功能 最开始接到这个任务的时候，我还有点懵逼，微信居然还可以实现这个功能啊，虽然在很久以前做过微信公众号的开发，但做的几乎就是手机网页，没怎么关注微信的这些接口，所以没有什么思绪。 这个时候，就只有去官方文档上面找思路了，结果果真找到了。下面大致说一下我的思路： 通过实现带参数的二维码创建不同的二维码 创建个性化菜单 对用户进行分组 1，创建测试账号登陆http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index微信扫码登录即可，然后配置接口信息，因为只是测试，所以我选择了最简单的新浪sae，这里有个注意点是，只有认证过的sae账户才可以，请大家一定要记住。 2，创建带参数的二维码参考此文档http://mp.weixin.qq.com/wiki/18/167e7d94df85d8389df6c94a7a8f78ba.html创建的二维码分为临时的和永久的，带参数的二维码主要是在post请求的时候传了一个scene_id,通过这个scene_id区分用户扫描的是哪一个二维码，然后通过这个二维码给用户进行分组即可。 接口调用说明：临时二维码：POST123URL: https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKENPOST数据格式：jsonPOST数据例子：&#123;&quot;expire_seconds&quot;: 604800, &quot;action_name&quot;: &quot;QR_SCENE&quot;, &quot;action_info&quot;: &#123;&quot;scene&quot;: &#123;&quot;scene_id&quot;: 123&#125;&#125;&#125; 永久二维码：POST12345URL: https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKENPOST数据格式：jsonPOST数据例子：&#123;&quot;action_name&quot;: &quot;QR_LIMIT_SCENE&quot;, &quot;action_info&quot;: &#123;&quot;scene&quot;: &#123;&quot;scene_id&quot;: 123&#125;&#125;&#125;或者也可以使用以下POST数据创建字符串形式的二维码参数：&#123;&quot;action_name&quot;: &quot;QR_LIMIT_STR_SCENE&quot;, &quot;action_info&quot;: &#123;&quot;scene&quot;: &#123;&quot;scene_str&quot;: &quot;123&quot;&#125;&#125;&#125; 3，创建个性化菜单参考此文档http://mp.weixin.qq.com/wiki/0/c48ccd12b69ae023159b4bfaa7c39c20.html 个性化菜单和正常的菜单主要区别就是多了一个匹配规则matchrule， 例如 123456789101112131415161718192021222324252627282930313233343536 &#123; "button":[ &#123; "type":"click", "name":"今日歌曲", "key":"V1001_TODAY_MUSIC" &#125;, &#123; "name":"菜单", "sub_button":[ &#123; "type":"view", "name":"搜索", "url":"http://www.soso.com/" &#125;, &#123; "type":"view", "name":"视频", "url":"http://v.qq.com/" &#125;, &#123; "type":"click", "name":"赞一下我们", "key":"V1001_GOOD" &#125;] &#125;],"matchrule":&#123; "group_id":"2", "sex":"1", "country":"中国", "province":"广东", "city":"广州", "client_platform_type":"2" "language":"zh_CN" &#125;&#125; 在上面的json数据中，matchrule中的group_id你就可以用上面创建带参数的二维码中的scene_id来区分，其他的参数如果没有特殊要求不填即可。 注意：创建个性化菜单的时候必须要有一个默认菜单，在删除默认菜单后，个性化菜单也会被删除 4，对用户进行分组参考此文档http://mp.weixin.qq.com/wiki/8/d6d33cf60bce2a2e4fb10a21be9591b8.html 接口调用请求说明POST（请使用https协议）123https://api.weixin.qq.com/cgi-bin/groups/members/update?access_token=ACCESS_TOKENPOST数据格式：jsonPOST数据例子：&#123;&quot;openid&quot;:&quot;oDF3iYx0ro3_7jD4HFRDfrjdCM58&quot;,&quot;to_groupid&quot;:108&#125; 5,代码实现我自己认为，像个性化菜单和自定义带参数的二维码没有必要代码生成，直接调用在线测试接口即可，所以，主要来讲一下用户分组的大致实现 怎么获取用户open_id？ 有人说这个用户的open_id是通过oauth授权得到的，其实在我们对用户进行分组的时候是不用这么做的，因为用户在订阅公众号或者其他消息请求的时候，会给传来一个fromUsername,这个fromUsername就是我们要的open_id 怎么获取 scene_id？ 用户在关注公众号的时候，会传过来一个EventKey，这个EventKey如果还没有关注的时候，值是会带一个qrscene_,例如qrscene_123,，而当用户已经关注了，再次扫描的时候直接传来的是123，这个123呢，就是我们所要获得的scene_id,也就是二维码中的参数。 123456789101112131415161718192021222324252627282930313233343536373839private function receiveEvent($object) &#123; $content = ""; switch ($object-&gt;Event) &#123; case "subscribe": $EventKey = $object-&gt;EventKey; if ($EventKey == 'qrscene_123') &#123; $groupid ='100'; &#125;else if ($EventKey == 'qrscene_143') &#123; $groupid = '101'; &#125; $fromUsername = $object-&gt;FromUserName; $access_token = $this-&gt;getAccessToken('app_id','app_secret'); $url = "https://api.weixin.qq.com/cgi-bin/groups/members/update?access_token=&#123;$access_token&#125;"; $post ='&#123;"openid":"'.$fromUsername.'","to_groupid":'.$groupid.'&#125;'; $this-&gt;_request($url,true,'POST',$post); $gid = ''; if($groupid == '101')&#123; $gid = 'doctor'; &#125;else if($groupid == '100')&#123; $gid = 'patient'; &#125; $content = "welcome &#123;$gid&#125;"; break; case "unsubscribe": $content = "取消关注"; break; case "CLICK": $content = $this-&gt;receiveClick($object); break; &#125; if (is_array($content)) &#123; $result = $this-&gt;transmitNews($object, $content); &#125; else &#123; $result = $this-&gt;transmitText($object, $content); &#125; return $result; &#125; 6，效果实现效果如下图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android布局优化技巧]]></title>
      <url>%2F2017%2F02%2F16%2FAndroid%E5%B8%83%E5%B1%80%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[include, merge , viewstub标签1，viewStub其实就是一个宽和高为0的view，通过setVisiblity或者inflate才能加载出来，从而达到延迟加载的效果2，include最常见的问题就是findViewById查找不到目标控件,先find include标签的id，再来找里面的viewId3，merge标签继承Activiy，里面有一个LinerLayout对象,在使用merge标签的时候，可以减少布局的层级 1234567891011121314151617/** * Exercise &lt;merge /&gt; tag in XML files. */ public class Merge extends Activity &#123; private LinearLayout mLayout; @Override protected void onCreate(Bundle icicle) &#123; super.onCreate(icicle); mLayout = new LinearLayout(this); mLayout.setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(this).inflate(R.layout.merge_tag, mLayout); setContentView(mLayout); &#125; public ViewGroup getLayout() &#123; return mLayout; &#125; &#125; 12345678910111213141516&lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;ImageView android:layout_width="fill_parent" android:layout_height="fill_parent" android:scaleType="center" android:src="@drawable/golden_gate" /&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="20dip" android:layout_gravity="center_horizontal|bottom" android:padding="12dip" android:background="#AA000000" android:textColor="#ffffffff" android:text="Golden Gate" /&gt;&lt;/merge&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
