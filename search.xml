<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[LRUCache缓存实现原理[转]]]></title>
      <url>%2F2018%2F03%2F29%2Flrucache%2F</url>
      <content type="text"><![CDATA[本文转自这里 Android中的缓存策略一般来说，缓存策略主要包含缓存的添加、获取和删除这三类操作。如何添加和获取缓存这个比较好理解，那么为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再想其添加缓存，这个时候就需要删除一些旧的缓存并添加新的缓存。 因此 LRU(Least Recently Used) 缓存算法便应运而生，LRU 是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象，有效的避免了 OOM 的出现。在 Android 中采用 LRU 算法的常用缓存有两种：LruCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。 其实LRU缓存的实现类似于一个特殊的栈，把访问过的元素放置到栈顶（若栈中存在，则更新至栈顶；若栈中不存在则直接入栈），然后如果栈中元素数量超过限定值，则删除栈底元素（即最近最少使用的元素）。详细算法实现如下图： 新数据压入到栈顶；每当缓存命中（即缓存数据被访问），则将数据移到栈顶；当栈满的时候，将栈底的数据丢弃。举个例子演示一下： LruCache的使用LruCache 是Android 3.1所提供的一个缓存类，所以在 Android 中可以直接使用LruCache实现内存缓存。而DisLruCache目前在 Android 还不是 Android SDK 的一部分，但Android官方文档推荐使用该算法来实现硬盘缓存。 讲到 LruCache不得不提一下LinkedHashMap，因为LruCache中 Lru 算法的实现就是通过LinkedHashMap来实现的。LinkedHashMap继承于HashMap，它使用了一个双向链表来存储Map中的Entry顺序关系，这种顺序有两种，一种是LRU顺序，一种是插入顺序，这可以由其构造函数 1public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder) 的最后一个参数accessOrder来指定。所以，对于get、put、remove等操作，LinkedHashMap除了要做HashMap做的事情，还做些调整Entry顺序链表的工作。LruCache中将LinkedHashMap的顺序设置为LRU顺序来实现LRU缓存，每次调用get(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用put插入新的对象也是存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。关于LinkedHashMap详解请前往：理解LinkedHashMap LruCache使用示例LruCache的使用非常简单，我们就以图片缓存为例： 12345678int maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);int cacheSize = maxMemory/8;mMemoryCache = new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes()*value.getHeight()/1024; &#125;&#125;; ① 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。② 重写sizeOf方法，计算出要缓存的每张图片的大小。 注意：缓存的总容量和每个缓存对象的大小所用单位要一致。 LruCache的实现原理LruCache的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队尾，即将被淘汰。而最近访问的对象将放在队头，最后被淘汰。如下图所示： 那么这个队列到底是由谁来维护的，前面已经介绍了是由LinkedHashMap来维护。 而LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序，使得LinkedHashMap中的对按照一定顺序排列起来。 通过下面构造函数来指定LinkedHashMap中双向链表的结构是访问顺序还是插入顺序。 1234567891011121314151617181920/** * Constructs a new &#123;@code LinkedHashMap&#125; instance with the specified * capacity, load factor and a flag specifying the ordering behavior. * * @param initialCapacity * the initial capacity of this hash map. * @param loadFactor * the initial load factor. * @param accessOrder * &#123;@code true&#125; if the ordering should be done based on the last * access (from least-recently accessed to most-recently * accessed), and &#123;@code false&#125; if the ordering should be the * order in which the entries were inserted. */public LinkedHashMap( int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); init(); this.accessOrder = accessOrder;&#125; 其中accessOrder设置为true则为访问顺序，为false，则为插入顺序。 以具体例子解释，当设置为true时： 12345678910111213141516public static final void main(String[] args) &#123; LinkedHashMap&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;&gt;(0, 0.75f, true); map.put(0, 0); map.put(1, 1); map.put(2, 2); map.put(3, 3); map.put(4, 4); map.put(5, 5); map.put(6, 6); map.get(1); //访问1 map.get(2); //访问2 for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ":" + entry.getValue()); &#125;&#125; 输出结果如下： 0:03:34:45:56:61:12:2 即最近访问的对象会被放到队尾，然后最后输出，那么这就正好满足的LRU缓存算法的思想。可见LruCache巧妙实现，就是利用了LinkedHashMap的这种数据结构。 下面我们在LruCache源码中具体看看，怎么应用LinkedHashMap来实现缓存的添加，获得和删除的。 LruCache源码分析我们先看看成员变量有哪些： 123456789101112131415public class LruCache&lt;K, V&gt; &#123; private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; //当前cache的大小 private int maxSize; //cache最大大小 private int putCount; //put的次数 private int createCount; //create的次数 private int evictionCount; //驱逐剔除的次数 private int hitCount; //命中的次数 private int missCount; //未命中次数 //...省略...&#125; 构造函数如下，可以看到LruCache正是用了LinkedHashMap的accessOrder=true构造参数实现LRU访问顺序： 12345678public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; //将LinkedHashMap的accessOrder设置为true来实现LRU顺序 this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; put方法1234567891011121314151617181920212223242526public final V put(K key, V value) &#123; //不可为空，否则抛出异常 if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; //旧值 synchronized (this) &#123; putCount++; //插入次数加1 size += safeSizeOf(key, value); //更新缓存的大小 previous = map.put(key, value); //如果已有缓存对象，则缓存大小的值需要剔除这个旧的大小 if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; //entryRemoved()是个空方法，可以自行实现 if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; //调整缓存大小(关键方法) trimToSize(maxSize); return previous;&#125; 可以看到put()方法并没有什么难点，重要的就是在添加过缓存对象后，调用trimToSize()方法，来判断缓存是否已满，如果满了就要删除近期最少使用的算法。 trimToSize方法12345678910111213141516171819202122232425262728public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; //如果map为空并且缓存size不等于0或者缓存size小于0，抛出异常 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //如果缓存大小size小于最大缓存，或者map为空，则不需要再删除缓存对象，跳出循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; //迭代器获取第一个对象，即队头的元素，近期最少访问的元素 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); //删除该对象，并更新缓存大小 map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125;&#125; trimToSize()方法不断地删除LinkedHashMap中队头的元素，即近期最少访问的，直到缓存大小小于最大值。 当调用LruCache的get()方法获取集合中的缓存对象时，就代表访问了一次该元素，将会更新队列，保持整个队列是按照访问顺序排序。这个更新过程就是在LinkedHashMap中的get()方法中完成的。 我们先看LruCache的get()方法。 get方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//LruCache的get()方法public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; //获取对应的缓存对象 //LinkedHashMap的get()方法会实现将访问的元素更新到队列尾部的功能 mapValue = map.get(key); //mapValue不为空表示命中，hitCount+1并返回mapValue对象 if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; //未命中 &#125; /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. * 如果未命中，则试图创建一个对象，这里create方法默认返回null,并没有实现创建对象的方法。 * 如果需要事项创建对象的方法可以重写create方法。因为图片缓存时内存缓存没有命中会去 * 文件缓存中去取或者从网络下载，所以并不需要创建，下面的就不用看了。 */ V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; //假如创建了新的对象，则继续往下执行 synchronized (this) &#123; createCount++; //将createdValue加入到map中，并且将原来键为key的对象保存到mapValue mapValue = map.put(key, createdValue); if (mapValue != null) &#123; // There was a conflict so undo that last put //如果mapValue不为空，则撤销上一步的put操作。 map.put(key, mapValue); &#125; else &#123; //加入新创建的对象之后需要重新计算size大小 size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; //每次新加入对象都需要调用trimToSize方法看是否需要回收 trimToSize(maxSize); return createdValue; &#125;&#125; 其中LinkedHashMap的get()方法如下： 12345678910//LinkedHashMap中的get方法public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; //实现排序的关键方法 if (accessOrder) afterNodeAccess(e); return e.value;&#125; 调用的afterNodeAccess()方法将该元素移到队尾，保证最后才删除，如下： 12345678910111213141516171819202122232425void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; //当前节点p移动到尾部之后，尾部指针指向当前节点 tail = p; ++modCount; &#125;&#125; 由此可见LruCache中维护了一个集合LinkedHashMap，该LinkedHashMap是以访问顺序排序的。当调用put()方法时，就会在结合中添加元素，并调用trimToSize()判断缓存是否已满，如果满了就用LinkedHashMap的迭代器删除队头元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队尾。 以上便是LruCache实现的原理，理解了LinkedHashMap的数据结构就能理解整个原理。如果不懂，可以先看看LinkedHashMap的具体实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android基础相关]]></title>
      <url>%2F2018%2F03%2F28%2F4%2F</url>
      <content type="text"><![CDATA[activity面试相关的问题 activity生命周期分析：activity启动 -&gt; onCreate()-&gt;onStart()-&gt;onResume() 点击home键回到主界面（activity不可见）-&gt;onPause()-&gt;onStop() 当我们再次回到原activity时-&gt;onRestart()-&gt;onStart()-&gt;onResume() 推出当前activity的时候-&gt;onPause()-&gt;onStop()-&gt;onDestroy() fragment FragmentPagerAdapter 与 FragmentStatePagerAdapter的区别： 答：当页面比较多的时候，我们选用FragmentStatePagerAdapter，因为在每次切换的时候，FragmentStatePagerAdapter会回收内存，具体看二者的onDestoryItem()方法，FragmentStatePagerAdapter最后调用的是transaction.remove(),而FragmentPagerAdapter调用的则是transaction.detach(),实际就是将fragment的ui与activity的ui分离，并没有回收 Fragment通信 答： 1，在fragment中调用activity的方法，getActivity()2，在activity中调用fragment中的方法，接口回调3，在fragment中调用fragment的方法，findFragmentById()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试相关（一）]]></title>
      <url>%2F2018%2F03%2F28%2F3%2F</url>
      <content type="text"><![CDATA[String,StringBuffer and StringBuilder 1.是否可变 String不可变，StringBuffer和StringBuilder可变。 2.是否线程安全 String不可变，因此是线程安全的。StringBuilder不是线程安全的；StringBuffer是线程安全的，使用synchronized来同步 String不可变的原因 可以缓存hash值 因为String的hash值经常被用到，例如String用作HashMap等。不可变的特性可以使得hash值也不可变，因此只需要一次计算 String Pool的需要 如果String已经被创建过了，那么就会从String Pool中取得引用。只有String是不可变的，才可能使用String Pool。 安全性 String经常作为参数，String的不可变性保证了参数不可变。例如在作为网络连接参数的情况下，如果String是可变的，那么在网络连接过程中，String被改变，改变String对象的那一方以为现在连接的是其他主机，而实际情况却不一定。 线程安全 String不可变性天生具备线程安全，可以在多个线程中使用。 == 与 equals() 区别 对于基本类型，== 判断两个值是否相等 对于引用类型，== 判断两个引用是否引用同一个对象，而 equals() 判断引用的对象是否等价 八个基本类型：boolean 1 byte 8 char 16 short 16 int 32 float 32 long 64 double 64]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ANR产生的原因及定位分析]]></title>
      <url>%2F2018%2F03%2F28%2F2%2F</url>
      <content type="text"><![CDATA[ANR（Application Not Responding），程序超过5秒没有响应，主要原因是因为在主线程中做了太多耗时操作。 1，ANR产生的原因 只有当应用程序的 UI 线程响应超时才会引起 ANR，超时产生原因一般有两种： 当前的事件没有机会得到处理，例如UI线程正在响应另一个事件，当前事件由于某种原因被阻塞了 当前的事件正在处理，但是由于耗时太长没能及时完成。 根据 ANR 产生原因不同，超时时间也不同，从本质上讲，产生 ANR 的原因有三种，分别对应到四大组件中的三个（Activity，BroadcastReceiver 和 Service）： KeyDispatchTimeout ：View的按键事件或者触摸事件5秒内无响应 BroadcastTimeout ：BroadcastReceiver 的onReceive()函数运行在主线程中，在10秒内无法完成处理 ServiceTimeout：这种情况比较少，原因是Service的各个生命周期在20秒内无法完成处理 2，典型的 ANR 问题场景 UI 线程存在耗时操作，例如在 UI 线程中进行网络请求，数据库操作或者文件操作等，可能会导致 UI 线程无法及时处理用户的输入等。在Android 4.0以后，如果在 UI 线程中进行网络操作，将会抛出NetworkOnMainThreadException异常 UI 线程等待子线程释放某个锁，从而无法处理用户的输入 耗时的动画需要大量的计算工作，可能导致 CPU 负载过重 3，ANR 的定位与分析 Logcat traces.txt 4，ANR 的避免和检测 StrictMode BlockCanary 4.1，StrictModeStrictMode是 Android SDK 提供的一个用来检测代码中是否存在违规操作的工具类，主要检测两大类问题： 线程策略 ThreadPolicy detectCustomSlowCalls：检测自定义耗时操作 detectDiskReads：检测是否存在磁盘读取操作 detectDiskWrites：检测是否存在磁盘写入操作 detectNetwork：检测是否存在网络操作 虚拟机策略 VmPolicy detectActivityLeaks：检测是否存在Activity泄漏 detectLeakedClosableObjects：检测是否存在未关闭的closable对象泄漏 detectLeakedSqlLiteObjects：检测是否存在Sqlite对象泄漏 setClassInstanceLimit：检测类实例个数是否超过限制 可以看到，其中 ThreadPolicy 可以用来检测可能存在的主线程耗时操作，解决这些检测可以减少 ANR 的概率。用法是在Application或者MainActivity的onCreate方法中执行如下代码 1234567891011121314@Override public void onCreate() &#123; //Debug中使用，release要关闭 if (BuildConfig.DEBUG)&#123; //开启线程模式 StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() .detectAll().penaltyLog().build()); //开启虚拟机模式 StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder() .detectAll().penaltyLog().build()); &#125; super.onCreate(); &#125; 4.2，BlockCanary基本原理是利用主线程的消息队列处理机制，通过对比消息分发开始和结束的时间点来判断是否超过设定的事件，如果是，则判断为主线程卡顿。具体参考官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Builder模式详解]]></title>
      <url>%2F2018%2F03%2F28%2F1%2F</url>
      <content type="text"><![CDATA[1，经典的Builder模式经典的Builder模式主要有四个参与者： Product：被构造的复杂对象，ConcreteBuilder用来创建该对象的内部表示，并定义它的装配过程 Builder：抽象接口，用来定义创建Product对象的各个组成部件的操作 ConcreteBuilder：Builder接口的具体实现，可以定义多个，是实际构建Product对象的地方，同时会提供一个返回Product的接口 Director：Builder接口的构造者和使用者 2，改造的Builder模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package BuilderDemo;public class User &#123; private String name; private String gender; private String age; private User(UserBuilder builder) &#123; this.name = builder.name; this.gender = builder.gender; this.age = builder.age; &#125; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender; &#125; public String getAge() &#123; return age; &#125; public static class UserBuilder &#123; private String name;//必填 private String gender;//非必填 private String age;//非必填 public UserBuilder(String name) &#123; this.name = name; &#125; public UserBuilder gender(String gender) &#123; this.gender = gender; return this; &#125; public UserBuilder age(String age) &#123; this.age = age; return this; &#125; public User build() &#123; return new User(this); &#125; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", gender='" + gender + '\'' + ", age='" + age + '\'' + '&#125;'; &#125;&#125; 12345678910public class test &#123; public static void main(String[] args) &#123; User user = new User.UserBuilder("lily") .age("18") .gender("female") .build(); System.out.println(user.toString()); System.out.println(user.getAge()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[策略模式]]></title>
      <url>%2F2018%2F03%2F21%2Fa03%2F</url>
      <content type="text"><![CDATA[策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 策略模式涉及到三个角色： 环境（context）角色：持有一个strategy的引用 抽象策略（Strategy）角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为 题目举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public interface ChargeStrategy &#123; //策略方法 double costFee(float displacement, int person, int mileage);&#125;public class LocalBus implements ChargeStrategy &#123; @Override public double costFee(float displacement, int person, int mileage) &#123; int cost; if (displacement &lt;= 1) &#123; cost = 0; &#125; else &#123; cost = 10; &#125; if (person &gt;= 6) &#123; cost += 10; &#125; if (mileage &gt; 100) &#123; cost += (mileage - 200) / 100 * 20; &#125; System.out.println("本地车辆---&gt;" + cost); return cost; &#125;&#125;public class OtherBus implements ChargeStrategy &#123; @Override public double costFee(float displacement, int person, int mileage) &#123; int cost; if (displacement &lt;= 1 &amp;&amp; displacement &gt; 0) &#123; cost = 10; &#125; else if (displacement &lt;= 2) &#123; cost = 20; &#125; else &#123; cost = 30; &#125; if (person &gt;= 6) &#123; cost += 20; &#125; if (mileage &gt; 100) &#123; cost += (mileage - 100) / 100 * 20; &#125; System.out.println("外地车辆---&gt;" + cost); return cost; &#125;&#125;public class Fee &#123; //持有一个具体策略的对象 ChargeStrategy strategy; //构造函数，传入一个具体策略对象 public Fee(ChargeStrategy strategy) &#123; this.strategy = strategy; &#125; //策略方法，计算收费 public double charge(float displacement, int person, int mileage) &#123; return this.strategy.costFee(displacement, person, mileage); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Fee fee = new Fee(new LocalBus()); fee.charge(2.7f, 6, 310); Fee fee1 = new Fee(new OtherBus()); fee1.charge(2.7f, 6, 310); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（二）Android View的绘制流程]]></title>
      <url>%2F2018%2F03%2F21%2Fa02%2F</url>
      <content type="text"><![CDATA[2.1 绘制的整体流程绘制会从根视图（ViewRoot）的performTraversal()方法开始，从上到下遍历整个视图树，每个View控制负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。 视图的绘制过程分为三个步骤，分别是测量（Measure）、布局（Layout）和绘制（Draw）。 2.2 MeasureSpecMeasureSpec表示的是一个32位的整数值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。MeasureSpec是View类的一个静态内部类，用来说明如果测量这个View, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** @hide */ @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode &#123;&#125; //不指定测量模式 public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; //精确测量模式 public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; //最大值测量模式 public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //根据指定的大小和模式创建一个MeasureSpec public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; //获取mode @MeasureSpecMode public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //根据spec获取大小 public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; //微调某个MeasureSpec static int adjust(int measureSpec, int delta) &#123; final int mode = getMode(measureSpec); int size = getSize(measureSpec); if (mode == UNSPECIFIED) &#123; // No need to adjust size for UNSPECIFIED mode. return makeMeasureSpec(size, UNSPECIFIED); &#125; size += delta; if (size &lt; 0) &#123; Log.e(VIEW_LOG_TAG, "MeasureSpec.adjust: new size would be negative! (" + size + ") spec: " + toString(measureSpec) + " delta: " + delta); size = 0; &#125; return makeMeasureSpec(size, mode); &#125; &#125; SpecMode有三种： UNSPECIFIED： 不指定测量模式，父视图没有限制子视图大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少使用到 EXACTLY： 精确测量模式，layout_width，layout_height为具体数值或match_parent时生效 AT_MOST： 最大值模式，layout_width，layout_height为wrap_content时生效，此时子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸 2.3 MeasureMeasure操作用来计算View的实际大小，页面流程从performMeasure方法开始。VeiwGroup遍历自身所有子View，并逐个调用子View的measure方法实现测量操作。 123456789101112131415161718192021222324252627282930 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; //当view gone的时候不测量 if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); //根据父容器的MeasureSpec和子view的layoutParams来算子view的MesureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... &#125; 最终测量通过回调onMeasure方法实现。开发者在自定义View的时候可以通过重写onMeasure来自定义测量过程，如果没有重写则会默认直接调用getDefaultSize来获取View的宽高。 2.4 LayoutLayout过程用来确定View在父容器中的布局位置，它是有父容器获取子View的位置参数后，调用子View的layout方法并将位置参数传入实现的。 2.5 DrawDraw用来将控件绘制出来，从performDraw开始，每个view的draw方法绘制每个具体的view，绘制基本上分为6个步骤： 123456789101112131415161718192021222324252627282930public void draw(Canvas canvas)&#123; ... //1，绘制View的背景 drawBackGround(canvas); ... //2，如果需要的话，保存canvas的图层，为fading做准备 saveConut = canvas.getSaveCount(); ... canvas.saveLayer(left,top,right,top+length,null,flags); ... //3，绘制view的内容 onDraw(canvas); ... //4，绘制view的子view dispatchDraw(canvas); ... //5，如果需要，绘制view的fading边缘并恢复图层 canvas.drawRect(left,top,right,top+length,p); ... canvas.restoreToCount(saveCount); ... //6，绘制view的装饰（例如滚动条） onDrawScrollBars(canvas); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（一）Android触摸事件传递机制]]></title>
      <url>%2F2018%2F03%2F21%2Fa01%2F</url>
      <content type="text"><![CDATA[1.1 触摸事件的类型 ACTION_DOWN ACTION_MOVE ACTION_UP 在一次屏幕触摸操作中，ACTION_DOWN 和 ACTION_UP 这两个事件是必须的，而ACTION_MOVE视情况而定。 1.2 事件传递的三个阶段 分发（dispatch）事件的分发对应着dispatchTouchEvent方法1public boolean dispatchTouchEvent(MotionEvent ev) 方法返回值为true表示事件被当前视图消费掉，不再继续分发事件；方法返回值为super.dispatchTouchEvent表示继续分发该事件。如果当前视图是ViewGroup及其子类，则会调用onInterceptTouchEvent方法判断是否拦截事件。 拦截（intercept）事件的拦截对应着onInterceptTouchEvent方法，这个方法只有在ViewGroup及其子类中才有，在View和Activity中是不存在的。 1public boolean onInterceptTouchEvent(MotionEvent ev) 返回ture表示拦截这个事件，不继续分发给子视图，同时交由自身的onTouchEvent方法进行消费； 返回false或者super.onInterceptTouchEvent表示不对事件进行拦截，继续传递给子视图。 消费（consumer） 事件的消费对应着onTouchEvent方法 1public boolean onTouchEvent(MotionEvent ev) 该方法返回值为true表示当前视图处理对应的事件，事件将不会向上传递给父视图；返回值为false表示当前视图不处理这个事件，事件会传递给父视图的onTouchEvent方法进行处理。 在Android系统中，拥有事件传递处理能力的类有以下3种： Activity：拥有dispatchTouchEvent和onTouchEvent两个方法 ViewGroup：拥有dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent三个方法 View：拥有dispatchTouchEvent和onTouchEvent两个方法 1.3 View的事件传递机制 触摸事件的传递流程是从dispatchTouchEvent开始的，如果不进行人为干预，则事件将会依照嵌套层次从外层向内层传递，到达最内层View时，就有它的onTouchEvent方法处理，如果该方法能够消费该事件，则返回true，反之false，这时事件会重新向外层传递，并有外层View的onTouchEvent方法进行处理，以此类推 如果事件在向内层传递过程中由于人为干预，事件处理函数返回true，则会导致事件提前被消费掉，内层View将不会收到这个事件 View控制的事件触发顺序是先执行onTouch方法，在最后才执行onClick方法。如果onTouch返回为true，则事件不会继续传递，最后也不会调用onClick方法；如果为false，则事件继续传递。 1.4 ViewGroup的事件传递机制 触摸事件的传递顺序是由Activity到ViewGroup，再由ViewGroup递归传递给它的子View ViewGroup通过onInterceptTouchEvent方法对事件进行拦截，如果该方法返回true，则事件不会继续传递给子View，如果返回false或者super.onInterceptTouchEvent，则事件会继续传递给子View 在子View种对事件进行消费后，ViewGroup将接收不到任何事件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native学习心得（二）]]></title>
      <url>%2F2017%2F07%2F23%2Frn002%2F</url>
      <content type="text"><![CDATA[React Native学习心得（二）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native学习心得（一）]]></title>
      <url>%2F2017%2F06%2F29%2Frn001%2F</url>
      <content type="text"><![CDATA[在学习React Native的时候，自己难免会遇到各种各样的问题，所以本文旨在记录一些自己在学习中遇到的心得。 第一个坑。。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信公众号个性化菜单的实现]]></title>
      <url>%2F2017%2F04%2F16%2F%E5%BE%AE%E4%BF%A1%E4%B8%AA%E6%80%A7%E5%8C%96%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[功能实现：微信扫描两个不同的二维码，关注的是相同的公众号，同一个公众号向不同关注者展示不同的菜单，实现了一个用户分类的功能 最开始接到这个任务的时候，我还有点懵逼，微信居然还可以实现这个功能啊，虽然在很久以前做过微信公众号的开发，但做的几乎就是手机网页，没怎么关注微信的这些接口，所以没有什么思绪。 这个时候，就只有去官方文档上面找思路了，结果果真找到了。下面大致说一下我的思路： 通过实现带参数的二维码创建不同的二维码 创建个性化菜单 对用户进行分组 1，创建测试账号登陆http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;t=sandbox/index微信扫码登录即可，然后配置接口信息，因为只是测试，所以我选择了最简单的新浪sae，这里有个注意点是，只有认证过的sae账户才可以，请大家一定要记住。 2，创建带参数的二维码参考此文档http://mp.weixin.qq.com/wiki/18/167e7d94df85d8389df6c94a7a8f78ba.html创建的二维码分为临时的和永久的，带参数的二维码主要是在post请求的时候传了一个scene_id,通过这个scene_id区分用户扫描的是哪一个二维码，然后通过这个二维码给用户进行分组即可。 接口调用说明：临时二维码：POST123URL: https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKENPOST数据格式：jsonPOST数据例子：&#123;&quot;expire_seconds&quot;: 604800, &quot;action_name&quot;: &quot;QR_SCENE&quot;, &quot;action_info&quot;: &#123;&quot;scene&quot;: &#123;&quot;scene_id&quot;: 123&#125;&#125;&#125; 永久二维码：POST12345URL: https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKENPOST数据格式：jsonPOST数据例子：&#123;&quot;action_name&quot;: &quot;QR_LIMIT_SCENE&quot;, &quot;action_info&quot;: &#123;&quot;scene&quot;: &#123;&quot;scene_id&quot;: 123&#125;&#125;&#125;或者也可以使用以下POST数据创建字符串形式的二维码参数：&#123;&quot;action_name&quot;: &quot;QR_LIMIT_STR_SCENE&quot;, &quot;action_info&quot;: &#123;&quot;scene&quot;: &#123;&quot;scene_str&quot;: &quot;123&quot;&#125;&#125;&#125; 3，创建个性化菜单参考此文档http://mp.weixin.qq.com/wiki/0/c48ccd12b69ae023159b4bfaa7c39c20.html 个性化菜单和正常的菜单主要区别就是多了一个匹配规则matchrule， 例如 123456789101112131415161718192021222324252627282930313233343536 &#123; "button":[ &#123; "type":"click", "name":"今日歌曲", "key":"V1001_TODAY_MUSIC" &#125;, &#123; "name":"菜单", "sub_button":[ &#123; "type":"view", "name":"搜索", "url":"http://www.soso.com/" &#125;, &#123; "type":"view", "name":"视频", "url":"http://v.qq.com/" &#125;, &#123; "type":"click", "name":"赞一下我们", "key":"V1001_GOOD" &#125;] &#125;],"matchrule":&#123; "group_id":"2", "sex":"1", "country":"中国", "province":"广东", "city":"广州", "client_platform_type":"2" "language":"zh_CN" &#125;&#125; 在上面的json数据中，matchrule中的group_id你就可以用上面创建带参数的二维码中的scene_id来区分，其他的参数如果没有特殊要求不填即可。 注意：创建个性化菜单的时候必须要有一个默认菜单，在删除默认菜单后，个性化菜单也会被删除 4，对用户进行分组参考此文档http://mp.weixin.qq.com/wiki/8/d6d33cf60bce2a2e4fb10a21be9591b8.html 接口调用请求说明POST（请使用https协议）123https://api.weixin.qq.com/cgi-bin/groups/members/update?access_token=ACCESS_TOKENPOST数据格式：jsonPOST数据例子：&#123;&quot;openid&quot;:&quot;oDF3iYx0ro3_7jD4HFRDfrjdCM58&quot;,&quot;to_groupid&quot;:108&#125; 5,代码实现我自己认为，像个性化菜单和自定义带参数的二维码没有必要代码生成，直接调用在线测试接口即可，所以，主要来讲一下用户分组的大致实现 怎么获取用户open_id？ 有人说这个用户的open_id是通过oauth授权得到的，其实在我们对用户进行分组的时候是不用这么做的，因为用户在订阅公众号或者其他消息请求的时候，会给传来一个fromUsername,这个fromUsername就是我们要的open_id 怎么获取 scene_id？ 用户在关注公众号的时候，会传过来一个EventKey，这个EventKey如果还没有关注的时候，值是会带一个qrscene_,例如qrscene_123,，而当用户已经关注了，再次扫描的时候直接传来的是123，这个123呢，就是我们所要获得的scene_id,也就是二维码中的参数。 123456789101112131415161718192021222324252627282930313233343536373839private function receiveEvent($object) &#123; $content = ""; switch ($object-&gt;Event) &#123; case "subscribe": $EventKey = $object-&gt;EventKey; if ($EventKey == 'qrscene_123') &#123; $groupid ='100'; &#125;else if ($EventKey == 'qrscene_143') &#123; $groupid = '101'; &#125; $fromUsername = $object-&gt;FromUserName; $access_token = $this-&gt;getAccessToken('app_id','app_secret'); $url = "https://api.weixin.qq.com/cgi-bin/groups/members/update?access_token=&#123;$access_token&#125;"; $post ='&#123;"openid":"'.$fromUsername.'","to_groupid":'.$groupid.'&#125;'; $this-&gt;_request($url,true,'POST',$post); $gid = ''; if($groupid == '101')&#123; $gid = 'doctor'; &#125;else if($groupid == '100')&#123; $gid = 'patient'; &#125; $content = "welcome &#123;$gid&#125;"; break; case "unsubscribe": $content = "取消关注"; break; case "CLICK": $content = $this-&gt;receiveClick($object); break; &#125; if (is_array($content)) &#123; $result = $this-&gt;transmitNews($object, $content); &#125; else &#123; $result = $this-&gt;transmitText($object, $content); &#125; return $result; &#125; 6，效果实现效果如下图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android布局优化技巧]]></title>
      <url>%2F2017%2F02%2F16%2FAndroid%E5%B8%83%E5%B1%80%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[include, merge , viewstub标签1，viewStub其实就是一个宽和高为0的view，通过setVisiblity或者inflate才能加载出来，从而达到延迟加载的效果2，include最常见的问题就是findViewById查找不到目标控件,先find include标签的id，再来找里面的viewId3，merge标签继承Activiy，里面有一个LinerLayout对象,在使用merge标签的时候，可以减少布局的层级 1234567891011121314151617/** * Exercise &lt;merge /&gt; tag in XML files. */ public class Merge extends Activity &#123; private LinearLayout mLayout; @Override protected void onCreate(Bundle icicle) &#123; super.onCreate(icicle); mLayout = new LinearLayout(this); mLayout.setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(this).inflate(R.layout.merge_tag, mLayout); setContentView(mLayout); &#125; public ViewGroup getLayout() &#123; return mLayout; &#125; &#125; 12345678910111213141516&lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;ImageView android:layout_width="fill_parent" android:layout_height="fill_parent" android:scaleType="center" android:src="@drawable/golden_gate" /&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="20dip" android:layout_gravity="center_horizontal|bottom" android:padding="12dip" android:background="#AA000000" android:textColor="#ffffffff" android:text="Golden Gate" /&gt;&lt;/merge&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
